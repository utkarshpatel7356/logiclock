from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
from dotenv import load_dotenv
from pydantic import BaseModel
from typing import List, Dict, Any
import asyncio
import os
import time
import pty
import subprocess
import select
import struct
import fcntl
import termios

import docker_manager
import arena_manager

load_dotenv()

# --- IN-MEMORY STATE ---
active_labs = {}

# --- BACKGROUND TASKS ---
async def zombie_reaper():
    """Checks every 10 seconds for inactive labs"""
    print("ðŸ’€ REAPER: Online and watching...")
    while True:
        await asyncio.sleep(10)
        try:
            now = time.time()
            to_kill = [cid for cid, last_seen in active_labs.items() if now - last_seen > 15]
            
            for cid in to_kill:
                print(f"ðŸ’€ REAPER: Lab {cid} timed out. Killing...")
                # CRITICAL FIX: Run stop_lab in a separate thread so it doesn't freeze the server
                await asyncio.to_thread(docker_manager.stop_lab, cid)
                
                # Safely remove from dict
                if cid in active_labs:
                    del active_labs[cid]
        except Exception as e:
            print(f"REAPER ERROR: {e}")

# --- LIFESPAN HANDLER ---
@asynccontextmanager
async def lifespan(app: FastAPI):
    print("---------- SYSTEM STARTUP ----------")
    # Clean orphans in a thread to avoid startup hang
    await asyncio.to_thread(docker_manager.cleanup_orphans)
    
    task = asyncio.create_task(zombie_reaper())
    yield
    print("---------- SYSTEM SHUTDOWN ----------")
    task.cancel()

# Initialize App
app = FastAPI(title="LogicLock Core", lifespan=lifespan)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- DATA MODELS ---
class LabRequest(BaseModel):
    image: str = "nginx:alpine"

class HeartbeatRequest(BaseModel):
    container_id: str

class MatchRequest(BaseModel):
    match_id: str
    role: str

class GraphPayload(BaseModel):
    nodes: List[Dict[str, Any]]
    edges: List[Dict[str, Any]]

# --- HTTP ROUTES ---

@app.get("/")
async def health():
    return {"status": "online", "active_labs": len(active_labs)}

@app.post("/lab/start")
async def start_lab(req: LabRequest):
    try:
        # THREAD FIX: Start lab in background thread
        result = await asyncio.to_thread(docker_manager.start_lab, req.image)
        active_labs[result["container_id"]] = time.time()
        print(f"â­ NEW LAB: {result['container_id']}")
        return result
    except Exception as e:
        raise HTTPException(500, detail=str(e))

@app.post("/lab/heartbeat")
async def heartbeat(req: HeartbeatRequest):
    if req.container_id in active_labs:
        active_labs[req.container_id] = time.time()
        return {"status": "alive"}
    return {"status": "unknown_lab"}

@app.post("/lab/stop")
async def stop_lab(req: HeartbeatRequest):
    # THREAD FIX: Stop lab in background thread
    await asyncio.to_thread(docker_manager.stop_lab, req.container_id)
    if req.container_id in active_labs:
        del active_labs[req.container_id]
    return {"status": "stopped"}

# --- ARENA ROUTES ---

@app.post("/arena/create")
async def create_arena():
    # THREAD FIX
    return await asyncio.to_thread(arena_manager.create_match)

@app.post("/arena/join")
async def join_arena(req: MatchRequest):
    try:
        # 1. Spin up the container (Background thread)
        result = await asyncio.to_thread(arena_manager.join_match, req.match_id, req.role)
        
        # 2. CRITICAL FIX: Register this container with the Reaper!
        # Now the system will track if this user is still online.
        active_labs[result["container_id"]] = time.time()
        
        return result
    except Exception as e:
        raise HTTPException(404, detail=str(e))

@app.get("/arena/score/{match_id}")
async def get_score(match_id: str):
    try:
        # THREAD FIX: Check score in background
        score = await asyncio.to_thread(arena_manager.check_score, match_id)
        if not score:
            raise HTTPException(404, detail="Match ended")
        return score
    except Exception as e:
        raise HTTPException(500, detail=str(e))

@app.post("/api/generate-script")
async def generate_script(payload: GraphPayload):
    """
    Compiles the visual graph into a realistic Bash script.
    """
    print(f"ðŸ“ COMPILING SCRIPT with {len(payload.nodes)} nodes...")
    
    # 1. Header with 'Shebang' and metadata
    script_lines = [
        "#!/bin/bash", 
        "# ----------------------------------------------------------------",
        "# ATTACK CHAIN GENERATED BY LOGICLOCK",
        "# TIMESTAMP: " + time.strftime("%Y-%m-%d %H:%M:%S"),
        "# WARNING: Authorized Use Only",
        "# ----------------------------------------------------------------",
        "",
        "# [SETUP] Define Colors",
        "RED='\\033[0;31m'",
        "GREEN='\\033[0;32m'",
        "NC='\\033[0m' # No Color",
        "",
        "echo -e \"${GREEN}[+] Initializing Attack Sequence...${NC}\"",
        ""
    ]
    
    # 2. Sort nodes by vertical position (Top -> Bottom execution)
    sorted_nodes = sorted(payload.nodes, key=lambda x: x['position']['y'])
    
    # 3. Generate commands based on node type
    for node in sorted_nodes:
        data = node.get('data', {})
        tool = data.get('tool', 'generic')
        args = data.get('args', '')
        label = data.get('label', 'Unknown Step')
        
        script_lines.append(f"# [STEP] {label}")
        script_lines.append(f"echo -e \"${{GREEN}}[+] Executing: {label} (${tool})...${{NC}}\"")
        
        # Tool Mapping Logic
        if tool == 'nmap':
            cmd = f"nmap {args} -oN scan_results.txt"
        elif tool == 'sqlmap':
            cmd = f"sqlmap -u \"{args}\" --batch --dbs"
        elif tool == 'hydra':
            cmd = f"hydra -l admin -P /usr/share/wordlists/rockyou.txt {args} http-post-form"
        elif tool == 'curl':
            cmd = f"curl -v {args}"
        else:
            cmd = f"# Custom Tool: {tool} {args}"
            
        script_lines.append(cmd)
        
        # Add error checking
        script_lines.append("if [ $? -ne 0 ]; then")
        script_lines.append(f"    echo -e \"${{RED}}[-] ERROR: {label} Failed!${{NC}}\"")
        script_lines.append("    exit 1")
        script_lines.append("fi")
        script_lines.append("sleep 1")
        script_lines.append("")
        
    script_lines.append("echo -e \"${GREEN}[+] Attack Chain Complete.${NC}\"")
    
    compiled_script = "\n".join(script_lines)
    
    return {
        "status": "compiled", 
        "script": compiled_script
    }

# --- WEBSOCKET ENDPOINT (NON-BLOCKING) ---
@app.websocket("/ws/shell/{container_id}")
async def websocket_shell(websocket: WebSocket, container_id: str):
    await websocket.accept()
    print(f"ðŸ”Œ WS CONNECTION: Client connected to {container_id}")
    
    master_fd = None
    process = None
    
    try:
        master_fd, slave_fd = pty.openpty()

        process = subprocess.Popen(
            ['docker', 'exec', '-it', container_id, '/bin/sh'],
            stdin=slave_fd,
            stdout=slave_fd,
            stderr=slave_fd,
            preexec_fn=os.setsid
        )
        os.close(slave_fd)

        loop = asyncio.get_running_loop()
        output_queue = asyncio.Queue()

        def on_pty_data():
            try:
                data = os.read(master_fd, 1024)
                if data: output_queue.put_nowait(data)
                else: output_queue.put_nowait(None)
            except OSError: output_queue.put_nowait(None)

        loop.add_reader(master_fd, on_pty_data)

        async def sender():
            while True:
                data = await output_queue.get()
                if data is None: break
                await websocket.send_text(data.decode('utf-8', errors='ignore'))

        async def receiver():
            while True:
                try:
                    data = await websocket.receive_text()
                    os.write(master_fd, data.encode())
                except WebSocketDisconnect: break
        
        done, pending = await asyncio.wait(
            [asyncio.create_task(sender()), asyncio.create_task(receiver())],
            return_when=asyncio.FIRST_COMPLETED
        )
        for task in pending: task.cancel()

    except Exception as e:
        print(f"WS Error: {e}")

    finally:
        print(f"ðŸ”Œ WS DISCONNECT: Client left {container_id}")
        if master_fd:
            loop.remove_reader(master_fd)
            os.close(master_fd)
        if process and process.poll() is None:
            process.terminate()
            process.wait()

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", 8000))
    uvicorn.run(app, host="0.0.0.0", port=port)